{% extends 'base.html' %}
{% load static %}

{% block title %}{{ page_title }} - GeoSudoku{% endblock %}

{% block extra_css %}
<style>
.game-container {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 2rem 0;
}

.game-board {
    background: white;
    border-radius: 1rem;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    padding: 2rem;
    margin-bottom: 2rem;
}

.game-header {
    background: white;
    border-radius: 1rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 1rem;
    margin-bottom: 2rem;
}

.shapes-panel {
    background: white;
    border-radius: 1rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
}

.grid-container {
    display: grid;
    gap: 3px;
    background-color: #333;
    padding: 15px;
    border-radius: 0.75rem;
    justify-content: center;
    margin: 0 auto;
    max-width: fit-content;
}

.grid-cell {
    width: 60px;
    height: 60px;
    background-color: white;
    border: 2px solid #ddd;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.grid-cell:hover {
    background-color: #f8f9fa;
    border-color: #007bff;
    transform: scale(1.05);
}

.grid-cell.fixed {
    background-color: #e9ecef;
    cursor: not-allowed;
}

.grid-cell.fixed:hover {
    transform: none;
    border-color: #ddd;
}

.grid-cell.selected {
    background-color: #007bff;
    border-color: #0056b3;
}

.grid-cell.correct {
    background-color: #d4edda;
    border-color: #28a745;
}

.grid-cell.incorrect {
    background-color: #f8d7da;
    border-color: #dc3545;
    animation: shake 0.5s;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

.shape-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.shape-icon svg {
    width: 100%;
    height: 100%;
}

.available-shapes {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    justify-content: center;
}

.shape-option {
    width: 60px;
    height: 60px;
    border: 2px solid #ddd;
    border-radius: 12px;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: grab;
    transition: all 0.3s ease;
    position: relative;
    user-select: none;
}

.shape-option:active {
    cursor: grabbing;
}

.shape-option:hover {
    border-color: #007bff;
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
}

.shape-option.selected {
    border-color: #007bff;
    background-color: #e3f2fd;
    transform: scale(1.05);
}

.shape-option.dragging {
    opacity: 0.5;
    transform: rotate(5deg) scale(1.1);
    z-index: 1000;
}

.grid-cell.drop-target {
    background-color: #e3f2fd;
    border-color: #007bff;
    border-style: dashed;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.grid-cell.drag-over {
    background-color: #fff3cd;
    border-color: #ffc107;
}

.shape-option svg {
    width: 40px;
    height: 40px;
    pointer-events: none;
}

.level-info {
    background: linear-gradient(45deg, #007bff, #0056b3);
    color: white;
    padding: 1rem;
    border-radius: 0.75rem;
    margin-bottom: 1rem;
}

.game-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.stat-card {
    background: rgba(255, 255, 255, 0.1);
    padding: 1rem;
    border-radius: 0.5rem;
    text-align: center;
}

.btn-back {
    background: linear-gradient(45deg, #6c757d, #495057);
    border: none;
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    transition: all 0.3s ease;
}

.btn-back:hover {
    background: linear-gradient(45deg, #495057, #343a40);
    color: white;
    text-decoration: none;
    transform: translateY(-2px);
}

.completion-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
    align-items: center;
    justify-content: center;
}

.completion-content {
    background: white;
    padding: 2rem;
    border-radius: 1rem;
    text-align: center;
    max-width: 400px;
    margin: 0 1rem;
}
</style>
{% endblock %}

{% block content %}
<div class="game-container">
    <div class="container">
        <!-- Level Info Header -->
        <div class="level-info">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <h4 class="mb-1">{{ level.name }}</h4>
                    <p class="mb-0">{{ shape_game.name }}</p>
                </div>
                <div class="text-end">
                    <h5 class="mb-1">Level {{ level.level_number }}</h5>
                    <small>Puzzle {{ level_puzzle.order_in_level }}</small>
                </div>
            </div>
            
            <div class="game-stats">
                <div class="stat-card">
                    <strong id="score">0</strong>
                    <div>Score</div>
                </div>
                <div class="stat-card">
                    <strong id="timer">{{ shape_game.max_time_minutes }}:00</strong>
                    <div>Time Left</div>
                </div>
                <div class="stat-card">
                    <strong>{{ shape_game.points_per_correct }}</strong>
                    <div>Points/Correct</div>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Game Board -->
            <div class="col-lg-8">
                <div class="game-board">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="mb-0">{{ shape_game.description|default:"Complete the pattern!" }}</h5>
                        <div class="btn-group">
                            <button type="button" class="btn btn-warning" onclick="showHint()">
                                <i class="fas fa-lightbulb"></i> Hint
                            </button>
                            <button type="button" class="btn btn-danger" onclick="resetGame()">
                                <i class="fas fa-undo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <!-- Grid -->
                    <div class="grid-container" id="game-grid">
                        <!-- Grid cells will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Shapes Panel -->
            <div class="col-lg-4">
                <div class="shapes-panel">
                    <h5 class="mb-3">Available Shapes</h5>
                    <div class="alert alert-info small">
                        <i class="fas fa-hand-pointer"></i> 
                        <strong>Drag & Drop:</strong> Drag shapes from here to the grid, or click a shape then click an empty cell.
                    </div>
                    <div class="available-shapes" id="available-shapes">
                        {% for shape in shape_game.available_shapes.all %}
                        <div class="shape-option" 
                             data-shape-id="{{ shape.id }}" 
                             data-shape-name="{{ shape.name }}"
                             data-shape-color="{{ shape.color }}"
                             draggable="true"
                             title="{{ shape.name }}">
                            <div class="shape-icon" style="color: {{ shape.color }};">
                                {{ shape.svg_data|safe }}
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                    
                    <hr>
                    
                    <div class="text-center">
                        <p class="mb-2"><strong>Instructions:</strong></p>
                        <p class="small text-muted">
                            Click on a shape below, then click on an empty cell in the grid to place it. 
                            Each row and column must contain each shape exactly once!
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Back Button -->
        <div class="text-center mt-3">
            <a href="{{ return_url }}" class="btn-back">
                <i class="fas fa-arrow-left"></i> Back to Level
            </a>
        </div>
    </div>
</div>

<!-- Completion Modal -->
<div class="completion-modal" id="completion-modal">
    <div class="completion-content">
        <div class="text-center">
            <i class="fas fa-trophy fa-3x text-warning mb-3"></i>
            <h4>Puzzle Completed!</h4>
            <p id="completion-message">Great job! You've completed this puzzle.</p>
            <div class="mt-3">
                <button type="button" class="btn btn-primary" onclick="backToLevel()">Back to Level</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Game state
let gameState = {
    selectedShape: null,
    gridState: [],
    score: 0,
    timeLeft: {{ shape_game.max_time_minutes }} * 60,
    isCompleted: false,
    draggedShape: null,
    draggedElement: null
};

// Game data from Django
const gameData = {
    gridTemplate: {{ shape_game.grid_template.grid_data|safe }},
    gridSize: {{ shape_game.grid_template.grid_size }},
    solutionData: {{ shape_game.solution_data|safe }},
    shapeGameId: {{ shape_game.id }},
    levelId: {{ level.id }},
    puzzleId: {{ level_puzzle.id }},
    pointsPerCorrect: {{ shape_game.points_per_correct }},
    penaltyPerWrong: {{ shape_game.penalty_per_wrong }},
    returnUrl: "{{ return_url }}"
};

// Available shapes mapping
const shapesMap = {
    {% for shape in shape_game.available_shapes.all %}
    {{ shape.id }}: {
        id: {{ shape.id }},
        name: "{{ shape.name }}",
        svg: `{{ shape.svg_data|safe }}`,
        color: "{{ shape.color }}"
    }{% if not forloop.last %},{% endif %}
    {% endfor %}
};

// Initialize game
document.addEventListener('DOMContentLoaded', function() {
    initializeGrid();
    initializeDragAndDrop();
    startTimer();
});

function initializeGrid() {
    const grid = document.getElementById('game-grid');
    const gridData = gameData.gridTemplate;
    
    // Set grid layout
    grid.style.gridTemplateColumns = `repeat(${gameData.gridSize}, 1fr)`;
    
    gameState.gridState = [];
    
    for (let row = 0; row < gameData.gridSize; row++) {
        gameState.gridState[row] = [];
        for (let col = 0; col < gameData.gridSize; col++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            const cellValue = gridData[row][col];
            
            // Handle different cell types
            if (typeof cellValue === 'object' && cellValue.shapeId) {
                // Pre-filled cell with shape
                cell.classList.add('fixed');
                const shape = getShapeById(cellValue.shapeId);
                if (shape) {
                    cell.innerHTML = `<div class="shape-icon" style="color: ${shape.color};">${shape.svg}</div>`;
                    gameState.gridState[row][col] = cellValue.shapeId;
                }
            } else if (cellValue === '?') {
                // Question mark cell - droppable
                cell.innerHTML = '<span style="color: #ffc107; font-size: 1.5em;">?</span>';
                cell.classList.add('drop-target');
                setupDropTarget(cell, row, col);
                gameState.gridState[row][col] = 0;
            } else {
                // Empty cell
                cell.innerHTML = '';
                gameState.gridState[row][col] = 0;
            }
            
            grid.appendChild(cell);
        }
    }
}

function initializeDragAndDrop() {
    // Setup drag events for shape options
    document.querySelectorAll('.shape-option').forEach(shapeElement => {
        // Drag start
        shapeElement.addEventListener('dragstart', function(e) {
            gameState.draggedShape = parseInt(this.dataset.shapeId);
            gameState.draggedElement = this;
            this.classList.add('dragging');
            
            // Create custom drag image
            const dragImage = this.cloneNode(true);
            dragImage.style.transform = 'rotate(5deg) scale(1.2)';
            e.dataTransfer.setDragImage(dragImage, 30, 30);
            e.dataTransfer.effectAllowed = 'copy';
        });
        
        // Drag end
        shapeElement.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('drag-over', 'drop-target-active');
            });
        });
        
        // Click selection (alternative to drag)
        shapeElement.addEventListener('click', function() {
            selectShape(parseInt(this.dataset.shapeId));
        });
    });
}

function setupDropTarget(cell, row, col) {
    // Dragover event
    cell.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        
        if (!this.classList.contains('fixed') && gameState.draggedShape) {
            this.classList.add('drag-over');
        }
    });
    
    // Dragleave event
    cell.addEventListener('dragleave', function(e) {
        this.classList.remove('drag-over');
    });
    
    // Drop event
    cell.addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('drag-over');
        
        if (!this.classList.contains('fixed') && gameState.draggedShape) {
            placeShapeByDrag(row, col, gameState.draggedShape);
        }
    });
    
    // Click event (for click-to-place)
    cell.addEventListener('click', function() {
        if (gameState.selectedShape && !this.classList.contains('fixed')) {
            placeShape(row, col);
        }
    });
}

function getShapeById(shapeId) {
    return shapesMap[shapeId] || null;
}

function selectShape(shapeId) {
    // Remove previous selection
    document.querySelectorAll('.shape-option').forEach(el => el.classList.remove('selected'));
    
    // Select new shape
    const shapeElement = document.querySelector(`[data-shape-id="${shapeId}"]`);
    if (shapeElement) {
        shapeElement.classList.add('selected');
        gameState.selectedShape = shapeId;
        
        // Highlight droppable cells
        document.querySelectorAll('.grid-cell.drop-target').forEach(cell => {
            if (!cell.classList.contains('fixed')) {
                cell.classList.add('drop-target-active');
            }
        });
    }
}

function placeShapeByDrag(row, col, shapeId) {
    if (gameState.isCompleted) return;
    
    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    if (cell.classList.contains('fixed')) return;
    
    placeShapeInCell(cell, row, col, shapeId);
    
    // Clear drag state
    gameState.draggedShape = null;
    gameState.draggedElement = null;
}

function placeShape(row, col) {
    if (!gameState.selectedShape || gameState.isCompleted) return;
    
    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    if (cell.classList.contains('fixed')) return;
    
    placeShapeInCell(cell, row, col, gameState.selectedShape);
    
    // Clear selection
    gameState.selectedShape = null;
    document.querySelectorAll('.shape-option').forEach(el => el.classList.remove('selected'));
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('drop-target-active');
    });
}

function placeShapeInCell(cell, row, col, shapeId) {
    // Place the shape
    const shape = getShapeById(shapeId);
    if (!shape) return;
    
    // Add placement animation
    cell.style.transform = 'scale(1.2)';
    setTimeout(() => {
        cell.style.transform = 'scale(1)';
    }, 200);
    
    cell.innerHTML = `<div class="shape-icon" style="color: ${shape.color};">${shape.svg}</div>`;
    gameState.gridState[row][col] = shapeId;
    
    // Validate placement
    if (validatePlacement(row, col, shapeId)) {
        cell.classList.add('correct');
        cell.classList.remove('incorrect');
        updateScore(gameData.pointsPerCorrect);
        
        // Check for completion
        checkCompletion();
    } else {
        cell.classList.add('incorrect');
        cell.classList.remove('correct');
        updateScore(-gameData.penaltyPerWrong);
        
        // Remove incorrect placement after animation
        setTimeout(() => {
            cell.innerHTML = '<span style="color: #ffc107; font-size: 1.5em;">?</span>';
            cell.classList.remove('incorrect');
            gameState.gridState[row][col] = 0;
        }, 1500);
    }
}

function validatePlacement(row, col, shapeId) {
    // Check against solution data if available
    if (gameData.solutionData) {
        const solutionGrid = gameData.solutionData;
        
        // Handle different solution data formats
        if (Array.isArray(solutionGrid)) {
            const solutionCell = solutionGrid[row][col];
            if (typeof solutionCell === 'object' && solutionCell.shapeId) {
                return solutionCell.shapeId == shapeId;
            }
            return solutionCell == shapeId;
        } else if (typeof solutionGrid === 'object') {
            const cellKey = `${row}-${col}`;
            return solutionGrid[cellKey] == shapeId;
        }
    }
    
    // If no solution data, assume all placements are valid for now
    return true;
}

function updateScore(points) {
    gameState.score = Math.max(0, gameState.score + points);
    document.getElementById('score').textContent = gameState.score;
    
    // Add score animation
    const scoreElement = document.getElementById('score');
    scoreElement.style.transform = 'scale(1.2)';
    scoreElement.style.color = points > 0 ? '#28a745' : '#dc3545';
    setTimeout(() => {
        scoreElement.style.transform = 'scale(1)';
        scoreElement.style.color = 'inherit';
    }, 300);
}

function checkCompletion() {
    // Check if all question mark cells are filled correctly
    let questionCellsFilled = 0;
    let totalQuestionCells = 0;
    
    const gridData = gameData.gridTemplate;
    for (let row = 0; row < gameData.gridSize; row++) {
        for (let col = 0; col < gameData.gridSize; col++) {
            if (gridData[row][col] === '?') {
                totalQuestionCells++;
                if (gameState.gridState[row][col] !== 0) {
                    questionCellsFilled++;
                }
            }
        }
    }
    
    if (questionCellsFilled === totalQuestionCells && totalQuestionCells > 0) {
        gameState.isCompleted = true;
        completePuzzle();
    }
}

function completePuzzle() {
    // Save completion to server
    saveGameCompletion();
    
    // Show completion modal
    document.getElementById('completion-message').innerHTML = 
        `<strong>Congratulations!</strong><br>Final Score: ${gameState.score}<br>Time: ${formatTime({{ shape_game.max_time_minutes }} * 60 - gameState.timeLeft)}`;
    document.getElementById('completion-modal').style.display = 'flex';
    
    // Celebrate with animations
    document.querySelectorAll('.grid-cell.correct').forEach((cell, index) => {
        setTimeout(() => {
            cell.style.animation = 'bounce 0.6s ease-in-out';
        }, index * 100);
    });
}

function saveGameCompletion() {
    // Send completion data to server
    fetch(`/api/levels/${gameData.levelId}/puzzles/${gameData.puzzleId}/complete/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({
            score: gameState.score,
            time_taken: {{ shape_game.max_time_minutes }} * 60 - gameState.timeLeft,
            final_state: gameState.gridState
        })
    }).catch(error => {
        console.error('Failed to save completion:', error);
    });
}

function startTimer() {
    const timer = setInterval(() => {
        if (gameState.timeLeft <= 0 || gameState.isCompleted) {
            clearInterval(timer);
            if (!gameState.isCompleted) {
                alert('Time\'s up! Try again.');
                setTimeout(() => {
                    location.reload();
                }, 2000);
            }
            return;
        }
        
        gameState.timeLeft--;
        document.getElementById('timer').textContent = formatTime(gameState.timeLeft);
    }, 1000);
}

function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

function showHint() {
    // Get a random unfilled question cell and show its solution
    const unfilledCells = [];
    const gridData = gameData.gridTemplate;
    
    for (let row = 0; row < gameData.gridSize; row++) {
        for (let col = 0; col < gameData.gridSize; col++) {
            if (gridData[row][col] === '?' && gameState.gridState[row][col] === 0) {
                unfilledCells.push({row, col});
            }
        }
    }
    
    if (unfilledCells.length === 0) {
        alert('No hints available - all cells are filled!');
        return;
    }
    
    const randomCell = unfilledCells[Math.floor(Math.random() * unfilledCells.length)];
    const hintCell = document.querySelector(`[data-row="${randomCell.row}"][data-col="${randomCell.col}"]`);
    
    // Highlight hint cell
    hintCell.style.boxShadow = '0 0 20px #ffc107';
    hintCell.style.backgroundColor = '#fff3cd';
    
    setTimeout(() => {
        hintCell.style.boxShadow = '';
        hintCell.style.backgroundColor = '';
    }, 3000);
    
    alert(`Hint: Check row ${randomCell.row + 1}, column ${randomCell.col + 1} - each shape should appear exactly once in each row and column!`);
}

function resetGame() {
    if (confirm('Are you sure you want to reset the game? All progress will be lost.')) {
        location.reload();
    }
}

function backToLevel() {
    window.location.href = gameData.returnUrl;
}
</script>
{% endblock %}